---
layout: post
title:  "LeetCode-1"
category: [algorithm ]
tags: [c++,sift,algorithms]
description: LeetCode-1
header-img: "img/pages/template.jpg"
---

##### 376. [Wiggle Subsequence，波浪序列](https://github.com/lichun-wang/LeetCode_2/blob/master/41First%20Missing%20Positive/376.%20Wiggle%20Subsequence/376main.cpp)
* 一、**题目大意：**

给定一个数组，找到最长的波浪序列，波浪序列为上升-下降-上升-下降。。。

* 二、**解题思路：**

采用动态规划的思想，首先新建结构体，记录当前最大长度以及是上升还是下降，即：</br>

```C++
struct len_dir{
        int length;
        bool up;
        len_dir(int len, bool u) :length(len), up(u){}
    };

```
然后新建数组 len_dir[n],初始化len_dir[0] 和len_dir[1] 然后，以后每一个跟前面的比较找到最长的一个，记录，然后返回len_dir[n-1]就是结果。


##### [97. Interleaving String](https://github.com/lichun-wang/LeetCode_2/blob/master/41First%20Missing%20Positive/97.%20Interleaving%20String/97main.cpp)
* 一、**题目大意：**

  >给定字符串s1、s2、s3, 判断s3是否可由s1与s2组成；
  >例如：
  >s1 = "aabcc",
  >s2 = "dbbca",
  >When s3 = "aadbbcbcac", return true.
  >When s3 = "aadbbbaccc", return false.
  
* 二、**解题思路：**

此题采用动态规划的思想，新建二维数组，递推公式如下：

f[i][j] = (f[i][j - 1] && s2[j - 1] == s3[i + j - 1]) || 
          (f[i - 1][j] && s1[i - 1] == s3[i + j - 1]);
说明如图所示
![递推示意图](images\leetcode97.jpg)






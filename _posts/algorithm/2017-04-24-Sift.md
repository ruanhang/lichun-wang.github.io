---
layout: post
title:  "特征检测理解"
category: [algorithm ]
tags: [c++,sift,algorithms]
description: 特征检测理解
header-img: "img/pages/template.jpg"
---

## SIFT原理：
参考链接：[http://blog.csdn.net/zddblog/article/details/7521424](http://blog.csdn.net/zddblog/article/details/7521424)
---
#### 关键点理解
* **二维高斯模糊**：SIFT算法是在不同的尺度空间上查找关键点，而尺度空间的获取需要使用高斯模糊来实现，Lindeberg等人已证明高斯卷积核是实现尺度变换的唯一变换核，并且是唯一的线性核。
* **尺度空间在实现时使用高斯金字塔表示**
   1. 对图像做不同尺度的高斯模糊；
   2. 对图像做降采样(隔点采样)。
* **高斯差分近似实现高斯拉普拉斯变换**：多尺度相减等效拉普拉斯
* **利用相邻差分图像，求取极值点**
* **DOG金字塔存在-1层** :防止丢掉最高层采样率,即图像本身
* **关键点定位**：
	1. 关键点检测
	2. 消除边缘相应：利用Hessian矩阵（**Hessian矩阵可用来求极值点，正定为极小值，负定为极大值，有正有负为鞍点**）
* **特征描述子生成**
	1. 根据每个特征点所在的高斯尺度（sigma）,确定梯度方向计算半径。
	2. 在半径内找到4*4*8个特征描述子。
	3. 特征描述子就是梯度方向以及大小。

## Harris角点检测：
参考链接：[http://www.360doc.com/content/15/1212/23/20007814_519967668.shtml](http://www.360doc.com/content/15/1212/23/20007814_519967668.shtml) 
---
#### 关键点理解
* 滑动窗口，向不同方向滑动，灰度变化较大，则证明是角点。
* 利用泰勒展开式，详情公示看参考链接
* 转化二次函数，**矩阵M的特征值为椭圆长轴短轴长度**:
>* 如果α，β都很小，说明高斯windows中的图像接近平坦。  
>* 如果一个大一个小，则表示检测到边。 C 
>* 如果α，β都很大，那么表示检测到了角点。

## 颜色特征：        
参考链接:[http://blog.csdn.net/tiandijun/article/details/45562163](http://blog.csdn.net/tiandijun/article/details/45562163)
---
#### 颜色直方图
* 用颜色空间三个分量的剥离得到颜色直方图，之后通过观察实验数据发现将图像进行旋转变换、缩放变换、模糊变换后图像的颜色直方图改变不大，即图像直方图对图像的物理变换是不敏感的。因此常提取颜色特征并用颜色直方图应用于衡量和比较两幅图像的全局差。另外，如果图像可以分为多个区域，并且前景与背景颜色分布具有明显差异，则颜色直方图呈现双峰形。
* 颜色直方图也有其缺点：由于颜色直方图是全局颜色统计的结果，因此丢失了像素点间的位置特征。可能有几幅图像具有相同或相近的颜色直方图，但其图像像素位置分布完全不同。因此，图像与颜色直方图得多对一关系使得颜色直方图在识别前景物体上不能获得很好的效果。  

#### 颜色矩
* 颜色矩是一种有效的颜色特征，由Stricker和Orengo提出[41]，该方法利用线性代数中矩的概念，将图像中的颜色分布用其矩表示。利用颜色一阶矩（平均值Average）、颜色二阶矩（方差Variance）和颜色三阶矩（偏斜度Skewness）来描述颜色分布。与颜色直方图不同，利用颜色矩进行图像描述无需量化图像特征。由于每个像素具有颜色空间的三个颜色通道，因此图像的颜色矩有9个分量来描述。由于颜色矩的维度较少，因此常将颜色矩与其他图像特征综合使用。

## 纹理特征（LBP特征）
参考链接：[http://blog.csdn.net/tiandijun/article/details/45561981](http://blog.csdn.net/tiandijun/article/details/45561981)     
#### 原理
原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（**通常转换为十进制数即LBP码，共256种**），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。如下图所示：
![LBP](http://img.blog.csdn.net/20150507154003000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGlhbmRpanVu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  
#### LBP算法步骤
* 1.用3*3的模板对图像每个像素进行处理，比较当前像素和周围像素的大小，将大于当前像素的置1，小于的置0。
* 2.对这周围八个像素进行编码，这八个0和1正好是可以组成一个byte数，然后按一定的规则组成这个无符号数。
* 3.把这个数赋值给当前像素。
* 4.通常对处理后的图像进行区域划分，比如分成4*4 、10*10或16*16的区域，对每个区域求得直方图，得到16、100或256个直方图。（划分都不是固定的）
* 5.这些直方图就是特征了，可以根据需要任意使用了。

## HOG特征
参考链接：[http://blog.csdn.net/hujingshuang/article/details/47337707/](http://blog.csdn.net/hujingshuang/article/details/47337707/)
#### 原理
是一种用于表征图像局部梯度方向和梯度强度分布特性的描述符。其主要思想是：在边缘具体位置未知的情况下，边缘方向的分布也可以很好的表示行人目标的外形轮廓。Dalal等提出的HOG+SVM算法，在进行行人检测取得了极大地成功后，更多新算法不断涌现，不过大都是以HOG+SVM的思路为主线。

#### 步骤

#### 1、颜色空间归一化
* 灰度化
* Gamma校正：采用方法为平方根或者对数法，计算后采用归一化操作到0-255。
#### 2、梯度计算
* 利用差分，分别计算x方向以及y方向的梯度
* sqrt(x*x+y*y)得到梯度，arctan(y/x)求角度
#### 3、梯度方向直方图
* 统计9个角度，每20度为一组
#### 4、重叠块直方图归一化    
由于图像中光照情况和背景的变化多样，梯度值的变化范围会比较大，因而良好的特征标准化对于检测率的提高相当重要。标准化的方法多种多样，大多数的都是将cell放在block中，然后标准化每个block。以上述图像为例，共得到27x38个cell，也就是将图像划分成了27x38个单元；将上下左右相邻的2x2个cells当做一个block整体，如下所示（为方便观察，每个颜色框故意错开了一点），黑色的8x8像素为一个cell，红、蓝、黄、粉红、绿框都是一个block，即每个框内2x2的cell组成一个block。故27x38个cell可划分成26x37个block，每个block为16x16像素。相邻block之间是有重叠的，这样有效的利用了相邻像素信息，对检测结果有很大的帮助。
![图像](http://img.blog.csdn.net/20150807151120252)
#### 5、HOG特征
实际上，在运用的时候，我们通常是选取一幅图像中的一个窗口来进行特征提取，依然以上述220X310大小图像为例，经过缩放处理后为216x304，但并不直接提取整个图像的HOG特征，而是用一个固定大小的窗口在图像上滑动，滑动的间隔为8个像素，OpenCV中默认的窗口大小为128x64（高128，宽64），即有(128÷8)x(64÷8)=16x8个cell，也即有15x7个block，这样一来一幅图像就可以取到(27-16)x(38-8)=11x30=330个窗口。现在提取每个窗口的HOG特征，则可得到105x36=3780维HOG特征向量。
